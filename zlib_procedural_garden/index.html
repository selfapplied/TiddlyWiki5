<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸŒ± ZLib Procedural Garden - Opcode Fractals</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Courier New', monospace;
            color: #00ff41;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        h1 {
            font-size: 2.5em;
            text-shadow: 0 0 20px #00ff41;
            margin: 0;
            background: linear-gradient(45deg, #00ff41, #41ff00, #ffff41);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            font-size: 1.2em;
            margin-top: 10px;
            opacity: 0.8;
        }
        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
            align-items: start;
        }
        .controls {
            background: rgba(0, 255, 65, 0.1);
            border: 2px solid #00ff41;
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        .control-group {
            margin-bottom: 25px;
        }
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #41ff00;
            text-shadow: 0 0 10px #41ff00;
        }
        .opcode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .opcode-btn {
            background: rgba(65, 255, 0, 0.2);
            border: 1px solid #41ff00;
            color: #41ff00;
            padding: 8px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }
        .opcode-btn:hover {
            background: rgba(65, 255, 0, 0.4);
            box-shadow: 0 0 15px rgba(65, 255, 0, 0.5);
        }
        .opcode-btn.active {
            background: rgba(65, 255, 0, 0.6);
            box-shadow: 0 0 20px rgba(65, 255, 0, 0.8);
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .slider {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ff41;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ff41;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }
        .generate-btn {
            width: 100%;
            background: linear-gradient(45deg, #00ff41, #41ff00);
            border: none;
            color: #000;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }
        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 65, 0.4);
        }
        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #00ff41;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            height: 600px;
        }
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff41;
            border-radius: 5px;
            padding: 10px;
            font-size: 0.8em;
            max-width: 200px;
        }
        .kernel-display {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #41ff00;
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }
        .kernel-matrix {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            margin-top: 10px;
        }
        .kernel-cell {
            background: rgba(65, 255, 0, 0.2);
            border: 1px solid #41ff00;
            padding: 5px;
            text-align: center;
            border-radius: 3px;
            font-size: 0.7em;
        }
        .legend {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #00ff41;
            border-radius: 5px;
            font-size: 0.9em;
        }
        .legend h4 {
            margin: 0 0 10px 0;
            color: #41ff00;
        }
        .legend-item {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #fff;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŒ± ZLib Procedural Garden</h1>
            <div class="subtitle">Compression Opcodes â†’ Convolution Kernels â†’ Fractal Flora</div>
        </div>
        
        <div class="main-container">
            <div class="controls">
                <div class="control-group">
                    <h3>ðŸ§¬ Opcode DNA</h3>
                    <div class="opcode-selector" id="opcodeSelector">
                        <!-- Dynamically populated -->
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>ðŸŒ¿ Growth Parameters</h3>
                    <div class="slider-container">
                        <label>Branching Factor: <span id="branchingValue">3</span></label>
                        <input type="range" class="slider" id="branchingSlider" min="2" max="8" value="3">
                    </div>
                    <div class="slider-container">
                        <label>Recursion Depth: <span id="depthValue">6</span></label>
                        <input type="range" class="slider" id="depthSlider" min="3" max="10" value="6">
                    </div>
                    <div class="slider-container">
                        <label>Mutation Rate: <span id="mutationValue">0.2</span></label>
                        <input type="range" class="slider" id="mutationSlider" min="0" max="1" step="0.1" value="0.2">
                    </div>
                    <div class="slider-container">
                        <label>Compression Ratio: <span id="compressionValue">1.5</span></label>
                        <input type="range" class="slider" id="compressionSlider" min="1" max="3" step="0.1" value="1.5">
                    </div>
                </div>
                
                <button class="generate-btn" onclick="generateGarden()">ðŸŒ± Generate Garden</button>
                
                <div class="kernel-display">
                    <h4>Current Kernel:</h4>
                    <div id="kernelName">None Selected</div>
                    <div class="kernel-matrix" id="kernelMatrix">
                        <!-- Dynamically populated -->
                    </div>
                </div>
                
                <div class="legend">
                    <h4>ðŸŽ¨ Legend:</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #8B4513;"></div>
                        <span>Trunk/Stems</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #228B22;"></div>
                        <span>Leaves</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFD700;"></div>
                        <span>Flowers</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF6347;"></div>
                        <span>Fruits</span>
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="gardenCanvas" width="800" height="600"></canvas>
                <div class="info-panel" id="infoPanel">
                    <strong>ðŸ”¬ Analysis:</strong><br>
                    Opcodes: <span id="opcodeCount">0</span><br>
                    Branches: <span id="branchCount">0</span><br>
                    Compression: <span id="compressionRatio">0%</span><br>
                    Entropy: <span id="entropyValue">0.0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ZLib opcode kernels - each opcode maps to a 3x3 convolution kernel
        const ZLIB_OPCODES = {
            'LITERAL': {
                kernel: [
                    [0, 1, 0],
                    [1, 1, 1], 
                    [0, 1, 0]
                ],
                description: 'Direct growth pattern',
                color: '#228B22'
            },
            'MATCH': {
                kernel: [
                    [1, 0, 1],
                    [0, 1, 0],
                    [1, 0, 1]
                ],
                description: 'Symmetrical branching',
                color: '#8B4513'
            },
            'DISTANCE': {
                kernel: [
                    [0, 0, 1],
                    [0, 1, 1],
                    [1, 1, 0]
                ],
                description: 'Spiral growth',
                color: '#FFD700'
            },
            'LENGTH': {
                kernel: [
                    [1, 1, 1],
                    [0, 1, 0],
                    [0, 1, 0]
                ],
                description: 'Linear extension',
                color: '#FF6347'
            },
            'HUFFMAN': {
                kernel: [
                    [1, 0, 0],
                    [1, 1, 0],
                    [1, 1, 1]
                ],
                description: 'Hierarchical branching',
                color: '#9370DB'
            },
            'LZ77': {
                kernel: [
                    [0, 1, 1],
                    [1, 1, 1],
                    [1, 1, 0]
                ],
                description: 'Reference pattern',
                color: '#20B2AA'
            }
        };

        let canvas, ctx;
        let selectedOpcodes = ['LITERAL'];
        let animationId;
        let currentGeneration = [];

        // Initialize the application
        function init() {
            canvas = document.getElementById('gardenCanvas');
            ctx = canvas.getContext('2d');
            
            // Setup opcode selector
            setupOpcodeSelector();
            setupSliders();
            
            // Initial generation
            generateGarden();
        }

        function setupOpcodeSelector() {
            const selector = document.getElementById('opcodeSelector');
            
            Object.keys(ZLIB_OPCODES).forEach(opcode => {
                const btn = document.createElement('div');
                btn.className = 'opcode-btn';
                btn.textContent = opcode;
                btn.onclick = () => toggleOpcode(opcode, btn);
                selector.appendChild(btn);
            });
            
            // Select first opcode by default
            selector.firstChild.classList.add('active');
            updateKernelDisplay();
        }

        function setupSliders() {
            const sliders = ['branching', 'depth', 'mutation', 'compression'];
            sliders.forEach(slider => {
                const element = document.getElementById(slider + 'Slider');
                const display = document.getElementById(slider + 'Value');
                
                // Set initial display value
                display.textContent = element.value;
                
                // Add both input and change event listeners
                element.addEventListener('input', function(e) {
                    display.textContent = this.value;
                    generateGarden();
                });
                
                element.addEventListener('change', function(e) {
                    display.textContent = this.value;
                    generateGarden();
                });
            });
        }

        function toggleOpcode(opcode, btn) {
            if (selectedOpcodes.includes(opcode)) {
                if (selectedOpcodes.length > 1) {
                    selectedOpcodes = selectedOpcodes.filter(o => o !== opcode);
                    btn.classList.remove('active');
                }
            } else {
                selectedOpcodes.push(opcode);
                btn.classList.add('active');
            }
            updateKernelDisplay();
            generateGarden();
        }

        function updateKernelDisplay() {
            const kernelName = document.getElementById('kernelName');
            const kernelMatrix = document.getElementById('kernelMatrix');
            
            if (selectedOpcodes.length === 1) {
                const opcode = selectedOpcodes[0];
                kernelName.textContent = `${opcode} - ${ZLIB_OPCODES[opcode].description}`;
                
                kernelMatrix.innerHTML = '';
                ZLIB_OPCODES[opcode].kernel.flat().forEach(value => {
                    const cell = document.createElement('div');
                    cell.className = 'kernel-cell';
                    cell.textContent = value;
                    cell.style.background = value ? 'rgba(65, 255, 0, 0.6)' : 'rgba(65, 255, 0, 0.1)';
                    kernelMatrix.appendChild(cell);
                });
            } else {
                kernelName.textContent = `Hybrid (${selectedOpcodes.join(' + ')})`;
                kernelMatrix.innerHTML = '<div style="grid-column: span 3; text-align: center;">Mixed Kernel</div>';
            }
        }

        function generateGarden() {
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get parameters
            const branching = parseInt(document.getElementById('branchingSlider').value);
            const depth = parseInt(document.getElementById('depthSlider').value);
            const mutation = parseFloat(document.getElementById('mutationSlider').value);
            const compression = parseFloat(document.getElementById('compressionSlider').value);
            
            // Generate plants using selected opcodes
            currentGeneration = [];
            const plantsPerRow = Math.ceil(Math.sqrt(selectedOpcodes.length * 3));
            const plantSpacing = canvas.width / (plantsPerRow + 1);
            
            let plantIndex = 0;
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < plantsPerRow && plantIndex < selectedOpcodes.length * 3; col++) {
                    const x = (col + 1) * plantSpacing;
                    const y = canvas.height - 50 - row * 150;
                    
                    const opcodeIndex = plantIndex % selectedOpcodes.length;
                    const opcode = selectedOpcodes[opcodeIndex];
                    
                    generatePlant(x, y, opcode, depth, branching, mutation, compression);
                    plantIndex++;
                }
            }
            
            updateAnalysis();
        }

        function generatePlant(startX, startY, opcode, depth, branching, mutation, compression) {
            const opcodeData = ZLIB_OPCODES[opcode];
            const kernel = opcodeData.kernel;
            const baseColor = opcodeData.color;
            
            // Plant structure
            const plant = {
                opcode: opcode,
                branches: [],
                totalBranches: 0
            };
            
            // Recursive growth using kernel as DNA
            function growBranch(x, y, angle, length, currentDepth, energy) {
                if (currentDepth >= depth || length < 5) return;
                
                // Apply kernel convolution to determine growth pattern
                const kernelIndex = currentDepth % 9;
                const kernelValue = kernel[Math.floor(kernelIndex / 3)][kernelIndex % 3];
                
                if (kernelValue === 0 && Math.random() > mutation) return;
                
                // Calculate branch properties
                const endX = x + Math.cos(angle) * length;
                const endY = y - Math.sin(angle) * length;
                
                // Draw branch
                ctx.strokeStyle = interpolateColor(baseColor, '#8B4513', currentDepth / depth);
                ctx.lineWidth = Math.max(1, (depth - currentDepth) * 2);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                plant.totalBranches++;
                
                // Add leaves/flowers based on compression ratio
                if (currentDepth > depth * 0.6) {
                    addFoliage(endX, endY, currentDepth, compression, baseColor);
                }
                
                // Generate child branches based on kernel pattern
                const branchCount = Math.min(branching, kernelValue + 1);
                for (let i = 0; i < branchCount; i++) {
                    const branchAngle = angle + (Math.PI / 6) * (i - branchCount / 2) * (1 + mutation * (Math.random() - 0.5));
                    const branchLength = length * (0.7 + mutation * (Math.random() - 0.5));
                    const branchEnergy = energy * (0.8 + 0.2 * kernelValue);
                    
                    setTimeout(() => {
                        growBranch(endX, endY, branchAngle, branchLength, currentDepth + 1, branchEnergy);
                    }, currentDepth * 50);
                }
            }
            
            // Start growth
            growBranch(startX, startY, Math.PI / 2, 60, 0, 1.0);
            currentGeneration.push(plant);
        }

        function addFoliage(x, y, depth, compression, baseColor) {
            const size = 3 + compression * 2;
            const foliageType = Math.random();
            
            if (foliageType < 0.6) {
                // Leaves
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.ellipse(x, y, size, size * 1.5, Math.random() * Math.PI, 0, 2 * Math.PI);
                ctx.fill();
            } else if (foliageType < 0.8) {
                // Flowers
                ctx.fillStyle = '#FFD700';
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * 2 * Math.PI;
                    const petalX = x + Math.cos(angle) * size;
                    const petalY = y + Math.sin(angle) * size;
                    ctx.beginPath();
                    ctx.arc(petalX, petalY, size * 0.7, 0, 2 * Math.PI);
                    ctx.fill();
                }
            } else {
                // Fruits
                ctx.fillStyle = '#FF6347';
                ctx.beginPath();
                ctx.arc(x, y, size * 1.2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function interpolateColor(color1, color2, factor) {
            // Simple color interpolation
            const result = color1.replace('#', '');
            const r1 = parseInt(result.substring(0, 2), 16);
            const g1 = parseInt(result.substring(2, 4), 16);
            const b1 = parseInt(result.substring(4, 6), 16);
            
            const result2 = color2.replace('#', '');
            const r2 = parseInt(result2.substring(0, 2), 16);
            const g2 = parseInt(result2.substring(2, 4), 16);
            const b2 = parseInt(result2.substring(4, 6), 16);
            
            const r = Math.round(r1 + factor * (r2 - r1));
            const g = Math.round(g1 + factor * (g2 - g1));
            const b = Math.round(b1 + factor * (b2 - b1));
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        function updateAnalysis() {
            const totalBranches = currentGeneration.reduce((sum, plant) => sum + plant.totalBranches, 0);
            const entropy = calculateEntropy();
            const compression = calculateCompressionRatio();
            
            document.getElementById('opcodeCount').textContent = selectedOpcodes.length;
            document.getElementById('branchCount').textContent = totalBranches;
            document.getElementById('compressionRatio').textContent = Math.round(compression * 100) + '%';
            document.getElementById('entropyValue').textContent = entropy.toFixed(2);
        }

        function calculateEntropy() {
            // Calculate Shannon entropy of the opcode distribution
            const distribution = {};
            selectedOpcodes.forEach(opcode => {
                distribution[opcode] = (distribution[opcode] || 0) + 1;
            });
            
            let entropy = 0;
            const total = selectedOpcodes.length;
            Object.values(distribution).forEach(count => {
                const p = count / total;
                entropy -= p * Math.log2(p);
            });
            
            return entropy;
        }

        function calculateCompressionRatio() {
            // Simulate compression ratio based on opcode complexity
            const complexityMap = {
                'LITERAL': 0.9,
                'MATCH': 0.7,
                'DISTANCE': 0.6,
                'LENGTH': 0.8,
                'HUFFMAN': 0.5,
                'LZ77': 0.4
            };
            
            const avgComplexity = selectedOpcodes.reduce((sum, opcode) => 
                sum + complexityMap[opcode], 0) / selectedOpcodes.length;
            
            return 1 - avgComplexity;
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html> 