{
  "symbols": {
    "math": {
      "type": "module",
      "mathematical_symbol": "math",
      "attributes": {}
    },
    "np": {
      "type": "module",
      "mathematical_symbol": "np",
      "attributes": {}
    },
    "PI": {
      "type": "constant",
      "mathematical_symbol": "PI",
      "attributes": {
        "value": null
      }
    },
    "MAX_ITERATIONS": {
      "type": "constant",
      "mathematical_symbol": "MAX_ITERATIONS",
      "attributes": {
        "value": null
      }
    },
    "fibonacci": {
      "type": "function",
      "mathematical_symbol": "fibonacci(n)",
      "attributes": {}
    },
    "factorial": {
      "type": "function",
      "mathematical_symbol": "factorial(n)",
      "attributes": {}
    },
    "Vector": {
      "type": "type",
      "mathematical_symbol": "Vector",
      "attributes": {}
    },
    "__init__": {
      "type": "function",
      "mathematical_symbol": "__init__(self, data)",
      "attributes": {}
    },
    "magnitude": {
      "type": "function",
      "mathematical_symbol": "magnitude(self)",
      "attributes": {}
    },
    "sqrt": {
      "type": "method",
      "mathematical_symbol": "math.sqrt",
      "attributes": {
        "class_name": "math"
      }
    },
    "add": {
      "type": "function",
      "mathematical_symbol": "add(self, other)",
      "attributes": {}
    },
    "Matrix": {
      "type": "type",
      "mathematical_symbol": "Matrix",
      "attributes": {}
    },
    "determinant": {
      "type": "function",
      "mathematical_symbol": "determinant(self)",
      "attributes": {}
    },
    "transpose": {
      "type": "method",
      "mathematical_symbol": "np.transpose",
      "attributes": {
        "class_name": "np"
      }
    },
    "compose_functions": {
      "type": "function",
      "mathematical_symbol": "compose_functions(f, g)",
      "attributes": {}
    },
    "h": {
      "type": "function",
      "mathematical_symbol": "h(x)",
      "attributes": {}
    },
    "f": {
      "type": "function",
      "mathematical_symbol": "f",
      "attributes": {}
    },
    "g": {
      "type": "function",
      "mathematical_symbol": "g",
      "attributes": {}
    },
    "result": {
      "type": "variable",
      "mathematical_symbol": "result",
      "attributes": {}
    },
    "vector": {
      "type": "variable",
      "mathematical_symbol": "vector",
      "attributes": {}
    },
    "matrix": {
      "type": "variable",
      "mathematical_symbol": "matrix",
      "attributes": {}
    }
  },
  "type_equivalence_classes": {
    "equivalence_classes": {
      "Vector": {
        "elements": [],
        "base_type": "Vector",
        "mathematical_symbol": "Vector",
        "group_actions": []
      },
      "Matrix": {
        "elements": [],
        "base_type": "Matrix",
        "mathematical_symbol": "Matrix",
        "group_actions": []
      }
    },
    "group_actions": {},
    "type_hierarchy": {},
    "mathematical_properties": []
  },
  "function_compositions": [
    {
      "f": "fibonacci",
      "g": "factorial",
      "composition": "fibonacci(n)"
    },
    {
      "f": "magnitude",
      "g": "add",
      "composition": "magnitude(self)"
    }
  ],
  "type_relations": [
    {
      "type1": "Vector",
      "relation": "compatible",
      "type2": "Matrix",
      "expression": "Vector_compatible_Matrix"
    }
  ],
  "insights": {
    "function_theorems": [
      "Theorem 1: Function composition is associative: (f \u2218 g) \u2218 h = f \u2218 (g \u2218 h)",
      "Theorem 2: Identity function is the unit for composition: f \u2218 id = id \u2218 f = f",
      "Theorem 3: Function symbols form a mathematical structure under composition"
    ],
    "type_theorems": [
      "Theorem 1: Types form equivalence classes under structural equality",
      "Theorem 2: Type hierarchy creates a partial order relation",
      "Theorem 3: Type group actions preserve type structure",
      "Theorem 4: Type compatibility is a reflexive and symmetric relation"
    ],
    "composition_properties": [
      "Property 1: Function composition preserves mathematical properties",
      "Property 2: Type composition creates new type structures",
      "Property 3: Method composition follows object-oriented principles",
      "Property 4: Constant composition creates derived constants"
    ],
    "equivalence_properties": [
      "Property 1: Type equivalence is reflexive, symmetric, and transitive",
      "Property 2: Equivalence classes partition the type space",
      "Property 3: Group actions preserve equivalence class structure",
      "Property 4: Type hierarchy respects equivalence relations"
    ]
  }
}