<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üå± Convolution Garden - Real Image Kernels</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Courier New', monospace;
            color: #00ff41;
            min-height: 100vh;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        h1 {
            font-size: 2.5em;
            text-shadow: 0 0 20px #00ff41;
            margin: 0;
            background: linear-gradient(45deg, #00ff41, #41ff00, #ffff41);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            font-size: 1.2em;
            margin-top: 10px;
            opacity: 0.8;
        }
        .main-container {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 30px;
            align-items: start;
        }
        .controls {
            background: rgba(0, 255, 65, 0.1);
            border: 2px solid #00ff41;
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        .control-group {
            margin-bottom: 25px;
        }
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #41ff00;
            text-shadow: 0 0 10px #41ff00;
        }
        .image-upload {
            border: 2px dashed #41ff00;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .image-upload:hover {
            background: rgba(65, 255, 0, 0.1);
        }
        .image-upload input {
            display: none;
        }
        .preview-image {
            max-width: 100%;
            max-height: 150px;
            border-radius: 5px;
            margin-top: 10px;
        }
        .kernel-display {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #41ff00;
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }
        .kernel-matrix {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            margin-top: 10px;
        }
        .kernel-cell {
            background: rgba(65, 255, 0, 0.2);
            border: 1px solid #41ff00;
            padding: 5px;
            text-align: center;
            border-radius: 3px;
            font-size: 0.7em;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .slider {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ff41;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ff41;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }
        .generate-btn {
            width: 100%;
            background: linear-gradient(45deg, #00ff41, #41ff00);
            border: none;
            color: #000;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }
        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 65, 0.4);
        }
        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #00ff41;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            height: 600px;
        }
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff41;
            border-radius: 5px;
            padding: 10px;
            font-size: 0.8em;
            max-width: 200px;
        }
        .legend {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #00ff41;
            border-radius: 5px;
            font-size: 0.9em;
        }
        .legend h4 {
            margin: 0 0 10px 0;
            color: #41ff00;
        }
        .legend-item {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #fff;
            border-radius: 3px;
        }
        .convolution-info {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #41ff00;
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
            font-size: 0.8em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå± Convolution Garden</h1>
            <div class="subtitle">Real Image Kernels ‚Üí Procedural Generation</div>
        </div>
        
        <div class="main-container">
            <div class="controls">
                <div class="control-group">
                    <h3>üñºÔ∏è Upload Image</h3>
                    <div class="image-upload" onclick="document.getElementById('imageInput').click()">
                        <div>üìÅ Click to upload image</div>
                        <div style="font-size: 0.8em; opacity: 0.7;">Extract convolution kernels from real images</div>
                        <input type="file" id="imageInput" accept="image/*" onchange="handleImageUpload(event)">
                        <img id="previewImage" class="preview-image" style="display: none;">
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>üîß Convolution Settings</h3>
                    <div class="slider-container">
                        <label>Kernel Size: <span id="kernelSizeValue">3</span></label>
                        <input type="range" class="slider" id="kernelSizeSlider" min="3" max="7" step="2" value="3">
                    </div>
                    <div class="slider-container">
                        <label>Convolution Threshold: <span id="thresholdValue">0.5</span></label>
                        <input type="range" class="slider" id="thresholdSlider" min="0" max="1" step="0.1" value="0.5">
                    </div>
                    <div class="slider-container">
                        <label>Growth Sensitivity: <span id="sensitivityValue">0.3</span></label>
                        <input type="range" class="slider" id="sensitivitySlider" min="0" max="1" step="0.1" value="0.3">
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>üåø Growth Parameters</h3>
                    <div class="slider-container">
                        <label>Branching Factor: <span id="branchingValue">3</span></label>
                        <input type="range" class="slider" id="branchingSlider" min="2" max="8" value="3">
                    </div>
                    <div class="slider-container">
                        <label>Recursion Depth: <span id="depthValue">6</span></label>
                        <input type="range" class="slider" id="depthSlider" min="3" max="10" value="6">
                    </div>
                    <div class="slider-container">
                        <label>Mutation Rate: <span id="mutationValue">0.2</span></label>
                        <input type="range" class="slider" id="mutationSlider" min="0" max="1" step="0.1" value="0.2">
                    </div>
                </div>
                
                <button class="generate-btn" onclick="generateGarden()">üå± Generate Garden</button>
                
                <div class="kernel-display">
                    <h4>Extracted Kernels:</h4>
                    <div id="kernelCount">0 kernels extracted</div>
                    <div id="kernelList">
                        <!-- Dynamically populated -->
                    </div>
                </div>
                
                <div class="convolution-info">
                    <h4>üî¨ Convolution Analysis:</h4>
                    <div id="convolutionStats">
                        <div>Image Size: <span id="imageSize">-</span></div>
                        <div>Kernels Found: <span id="kernelsFound">0</span></div>
                        <div>Pattern Strength: <span id="patternStrength">0.0</span></div>
                        <div>Entropy: <span id="entropyValue">0.0</span></div>
                    </div>
                </div>
                
                <div class="legend">
                    <h4>üé® Legend:</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #8B4513;"></div>
                        <span>Trunk/Stems</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #228B22;"></div>
                        <span>Leaves</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFD700;"></div>
                        <span>Flowers</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF6347;"></div>
                        <span>Fruits</span>
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="gardenCanvas" width="800" height="600"></canvas>
                <div class="info-panel" id="infoPanel">
                    <strong>üî¨ Analysis:</strong><br>
                    Kernels: <span id="opcodeCount">0</span><br>
                    Branches: <span id="branchCount">0</span><br>
                    Convolution: <span id="convolutionRatio">0%</span><br>
                    Growth: <span id="growthValue">0.0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        let canvas, ctx;
        let extractedKernels = [];
        let imageData = null;
        let currentGeneration = [];

        // Initialize the application
        function init() {
            canvas = document.getElementById('gardenCanvas');
            ctx = canvas.getContext('2d');
            
            setupSliders();
            
            // Initial generation with default kernels
            generateDefaultKernels();
            generateGarden();
        }

        function setupSliders() {
            const sliders = ['kernelSize', 'threshold', 'sensitivity', 'branching', 'depth', 'mutation'];
            sliders.forEach(slider => {
                const element = document.getElementById(slider + 'Slider');
                const display = document.getElementById(slider + 'Value');
                
                // Set initial display value
                display.textContent = element.value;
                
                // Add both input and change event listeners
                element.addEventListener('input', function(e) {
                    display.textContent = this.value;
                    if (slider === 'kernelSize' || slider === 'threshold') {
                        extractKernelsFromImage();
                    }
                    generateGarden();
                });
                
                element.addEventListener('change', function(e) {
                    display.textContent = this.value;
                    if (slider === 'kernelSize' || slider === 'threshold') {
                        extractKernelsFromImage();
                    }
                    generateGarden();
                });
            });
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // Display preview
                        const preview = document.getElementById('previewImage');
                        preview.src = e.target.result;
                        preview.style.display = 'block';
                        
                        // Extract image data
                        extractImageData(img);
                        extractKernelsFromImage();
                        generateGarden();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function extractImageData(img) {
            // Create temporary canvas to get image data
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Resize for processing (keep aspect ratio)
            const maxSize = 256;
            const scale = Math.min(maxSize / img.width, maxSize / img.height);
            const width = Math.floor(img.width * scale);
            const height = Math.floor(img.height * scale);
            
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCtx.drawImage(img, 0, 0, width, height);
            
            imageData = tempCtx.getImageData(0, 0, width, height);
            
            // Update stats
            document.getElementById('imageSize').textContent = `${width}√ó${height}`;
        }

        function extractKernelsFromImage() {
            if (!imageData) {
                generateDefaultKernels();
                return;
            }

            const kernelSize = parseInt(document.getElementById('kernelSizeSlider').value);
            const threshold = parseFloat(document.getElementById('thresholdSlider').value);
            const sensitivity = parseFloat(document.getElementById('sensitivitySlider').value);
            
            extractedKernels = [];
            
            // Extract kernels using real convolution
            for (let y = kernelSize; y < imageData.height - kernelSize; y += kernelSize) {
                for (let x = kernelSize; x < imageData.width - kernelSize; x += kernelSize) {
                    const kernel = extractKernelAt(x, y, kernelSize);
                    const strength = calculateKernelStrength(kernel);
                    
                    if (strength > threshold) {
                        // Normalize kernel
                        const normalizedKernel = normalizeKernel(kernel, sensitivity);
                        extractedKernels.push({
                            kernel: normalizedKernel,
                            strength: strength,
                            position: {x, y}
                        });
                    }
                }
            }
            
            // Sort by strength and take top kernels
            extractedKernels.sort((a, b) => b.strength - a.strength);
            extractedKernels = extractedKernels.slice(0, 6); // Top 6 kernels
            
            updateKernelDisplay();
            updateConvolutionStats();
        }

        function extractKernelAt(x, y, size) {
            const kernel = [];
            const halfSize = Math.floor(size / 2);
            
            for (let ky = -halfSize; ky <= halfSize; ky++) {
                const row = [];
                for (let kx = -halfSize; kx <= halfSize; kx++) {
                    const pixelX = x + kx;
                    const pixelY = y + ky;
                    const pixelIndex = (pixelY * imageData.width + pixelX) * 4;
                    
                    // Convert to grayscale and normalize
                    const r = imageData.data[pixelIndex];
                    const g = imageData.data[pixelIndex + 1];
                    const b = imageData.data[pixelIndex + 2];
                    const gray = (r + g + b) / 3 / 255; // Normalize to 0-1
                    
                    row.push(gray);
                }
                kernel.push(row);
            }
            
            return kernel;
        }

        function calculateKernelStrength(kernel) {
            // Calculate variance as a measure of pattern strength
            let sum = 0;
            let sumSq = 0;
            let count = 0;
            
            for (let i = 0; i < kernel.length; i++) {
                for (let j = 0; j < kernel[i].length; j++) {
                    sum += kernel[i][j];
                    sumSq += kernel[i][j] * kernel[i][j];
                    count++;
                }
            }
            
            const mean = sum / count;
            const variance = (sumSq / count) - (mean * mean);
            
            return variance;
        }

        function normalizeKernel(kernel, sensitivity) {
            // Normalize kernel values based on sensitivity
            const normalized = [];
            for (let i = 0; i < kernel.length; i++) {
                const row = [];
                for (let j = 0; j < kernel[i].length; j++) {
                    // Apply sensitivity threshold
                    const value = kernel[i][j] > sensitivity ? kernel[i][j] : 0;
                    row.push(value);
                }
                normalized.push(row);
            }
            return normalized;
        }

        function generateDefaultKernels() {
            // Default kernels when no image is loaded
            extractedKernels = [
                {
                    kernel: [[0, 1, 0], [1, 1, 1], [0, 1, 0]],
                    strength: 0.5,
                    position: {x: 0, y: 0}
                },
                {
                    kernel: [[1, 0, 1], [0, 1, 0], [1, 0, 1]],
                    strength: 0.4,
                    position: {x: 0, y: 0}
                }
            ];
            updateKernelDisplay();
        }

        function updateKernelDisplay() {
            const kernelCount = document.getElementById('kernelCount');
            const kernelList = document.getElementById('kernelList');
            
            kernelCount.textContent = `${extractedKernels.length} kernels extracted`;
            
            kernelList.innerHTML = '';
            extractedKernels.forEach((kernelData, index) => {
                const kernelDiv = document.createElement('div');
                kernelDiv.style.marginBottom = '10px';
                kernelDiv.innerHTML = `
                    <div style="font-size: 0.7em; margin-bottom: 5px;">Kernel ${index + 1} (strength: ${kernelData.strength.toFixed(2)})</div>
                    <div class="kernel-matrix">
                        ${kernelData.kernel.flat().map(value => 
                            `<div class="kernel-cell" style="background: ${value > 0 ? 'rgba(65, 255, 0, 0.6)' : 'rgba(65, 255, 0, 0.1)'}">${value.toFixed(2)}</div>`
                        ).join('')}
                    </div>
                `;
                kernelList.appendChild(kernelDiv);
            });
        }

        function updateConvolutionStats() {
            const totalStrength = extractedKernels.reduce((sum, k) => sum + k.strength, 0);
            const avgStrength = totalStrength / Math.max(extractedKernels.length, 1);
            
            document.getElementById('kernelsFound').textContent = extractedKernels.length;
            document.getElementById('patternStrength').textContent = avgStrength.toFixed(2);
            document.getElementById('entropyValue').textContent = calculateEntropy().toFixed(2);
        }

        function generateGarden() {
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get parameters
            const branching = parseInt(document.getElementById('branchingSlider').value);
            const depth = parseInt(document.getElementById('depthSlider').value);
            const mutation = parseFloat(document.getElementById('mutationSlider').value);
            
            // Generate plants using extracted kernels
            currentGeneration = [];
            const plantsPerRow = Math.ceil(Math.sqrt(extractedKernels.length * 3));
            const plantSpacing = canvas.width / (plantsPerRow + 1);
            
            let plantIndex = 0;
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < plantsPerRow && plantIndex < extractedKernels.length * 3; col++) {
                    const x = (col + 1) * plantSpacing;
                    const y = canvas.height - 50 - row * 150;
                    
                    const kernelIndex = plantIndex % extractedKernels.length;
                    const kernelData = extractedKernels[kernelIndex];
                    
                    generatePlant(x, y, kernelData, depth, branching, mutation);
                    plantIndex++;
                }
            }
            
            updateAnalysis();
        }

        function generatePlant(startX, startY, kernelData, depth, branching, mutation) {
            const kernel = kernelData.kernel;
            const strength = kernelData.strength;
            
            // Plant structure
            const plant = {
                kernel: kernel,
                strength: strength,
                totalBranches: 0
            };
            
            // Recursive growth using REAL convolution
            function growBranch(x, y, angle, length, currentDepth, energy) {
                if (currentDepth >= depth || length < 5) return;
                
                // Apply REAL convolution to determine growth pattern
                const convolutionResult = applyConvolution(kernel, currentDepth);
                
                if (convolutionResult < 0.1 && Math.random() > mutation) return;
                
                // Calculate branch properties based on convolution
                const endX = x + Math.cos(angle) * length;
                const endY = y - Math.sin(angle) * length;
                
                // Draw branch with color based on convolution strength
                const colorIntensity = Math.min(255, convolutionResult * 255);
                ctx.strokeStyle = `rgb(${colorIntensity}, ${255 - colorIntensity}, 100)`;
                ctx.lineWidth = Math.max(1, (depth - currentDepth) * 2);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                plant.totalBranches++;
                
                // Add foliage based on convolution pattern
                if (currentDepth > depth * 0.6) {
                    addFoliage(endX, endY, currentDepth, convolutionResult);
                }
                
                // Generate child branches based on convolution
                const branchCount = Math.min(branching, Math.floor(convolutionResult * branching) + 1);
                for (let i = 0; i < branchCount; i++) {
                    const branchAngle = angle + (Math.PI / 6) * (i - branchCount / 2) * (1 + mutation * (Math.random() - 0.5));
                    const branchLength = length * (0.7 + mutation * (Math.random() - 0.5));
                    const branchEnergy = energy * (0.8 + 0.2 * convolutionResult);
                    
                    setTimeout(() => {
                        growBranch(endX, endY, branchAngle, branchLength, currentDepth + 1, branchEnergy);
                    }, currentDepth * 50);
                }
            }
            
            // Start growth
            growBranch(startX, startY, Math.PI / 2, 60, 0, 1.0);
            currentGeneration.push(plant);
        }

        function applyConvolution(kernel, depth) {
            // REAL convolution: simulate neighborhood and apply kernel
            const neighborhood = generateNeighborhood(depth);
            let result = 0;
            
            for (let i = 0; i < kernel.length; i++) {
                for (let j = 0; j < kernel[i].length; j++) {
                    result += kernel[i][j] * neighborhood[i][j];
                }
            }
            
            return Math.max(0, Math.min(1, result));
        }

        function generateNeighborhood(depth) {
            // Generate a neighborhood based on growth depth
            const size = 3;
            const neighborhood = [];
            
            for (let i = 0; i < size; i++) {
                const row = [];
                for (let j = 0; j < size; j++) {
                    // Create pattern based on depth and position
                    const value = Math.sin(depth * 0.5 + i * 0.3 + j * 0.2) * 0.5 + 0.5;
                    row.push(value);
                }
                neighborhood.push(row);
            }
            
            return neighborhood;
        }

        function addFoliage(x, y, depth, convolutionResult) {
            const size = 3 + convolutionResult * 5;
            const foliageType = Math.random();
            
            if (foliageType < 0.6) {
                // Leaves
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.ellipse(x, y, size, size * 1.5, Math.random() * Math.PI, 0, 2 * Math.PI);
                ctx.fill();
            } else if (foliageType < 0.8) {
                // Flowers
                ctx.fillStyle = '#FFD700';
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * 2 * Math.PI;
                    const petalX = x + Math.cos(angle) * size;
                    const petalY = y + Math.sin(angle) * size;
                    ctx.beginPath();
                    ctx.arc(petalX, petalY, size * 0.7, 0, 2 * Math.PI);
                    ctx.fill();
                }
            } else {
                // Fruits
                ctx.fillStyle = '#FF6347';
                ctx.beginPath();
                ctx.arc(x, y, size * 1.2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function updateAnalysis() {
            const totalBranches = currentGeneration.reduce((sum, plant) => sum + plant.totalBranches, 0);
            const avgStrength = currentGeneration.reduce((sum, plant) => sum + plant.strength, 0) / Math.max(currentGeneration.length, 1);
            
            document.getElementById('opcodeCount').textContent = extractedKernels.length;
            document.getElementById('branchCount').textContent = totalBranches;
            document.getElementById('convolutionRatio').textContent = Math.round(avgStrength * 100) + '%';
            document.getElementById('growthValue').textContent = avgStrength.toFixed(2);
        }

        function calculateEntropy() {
            if (extractedKernels.length === 0) return 0;
            
            // Calculate Shannon entropy of kernel strengths
            const strengths = extractedKernels.map(k => k.strength);
            const total = strengths.reduce((sum, s) => sum + s, 0);
            
            let entropy = 0;
            strengths.forEach(strength => {
                const p = strength / total;
                if (p > 0) {
                    entropy -= p * Math.log2(p);
                }
            });
            
            return entropy;
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html> 